#include "XtcRun.hh"

#include "pdsdata/xtc/Sequence.hh"
#include "pdsdata/xtc/TransitionId.hh"

#include <fcntl.h>
#include <semaphore.h>

#include <queue>
using std::queue;

//#define DUMP_DMGOFF

static bool _live=false;

static void* readSlice(void* arg);

void XtcRun::live_read(bool l) { _live=l; }

class XtcPool {
public:
  XtcPool(unsigned nevents, unsigned eventsize) :
    _eventsize(eventsize)
  {
    sem_init(&_pend_sem, 0, 0);
    sem_init(&_free_sem, 0, nevents);
    while(nevents--) {
      char* b = new char[eventsize];
      _free.push(b);
    }
  }
  ~XtcPool()
  {
    sem_destroy(&_pend_sem);
    sem_destroy(&_free_sem);
    while(!_pend.empty()) {
      char* b = _pend.front();
      if (b) delete b;
      _pend.pop();
    }
    while(!_free.empty()) {
      delete _free.front();
      _free.pop();
    }
  }
public:
  //
  //  Read a complete event into the pool from file descriptor 'fd'.
  //  Upon failure, insert 0 into the pool and return false
  //  For 'live' file read, always return true.
  //
  bool push(int fd)
  {
    sem_wait(&_free_sem);
    char* b = _free.front();
    _free.pop();

    unsigned sz = sizeof(Pds::Dgram);
    ssize_t rsz = ::read(fd, b, sz);

    if (rsz == ssize_t(sz)) {
      Pds::Dgram* dg = reinterpret_cast<Pds::Dgram*>(b);
      sz = dg->xtc.sizeofPayload();

#ifdef DUMP_DMGOFF
      if (dg->xtc.damage.value()&(1<<Pds::Damage::DroppedContribution)) {
        off64_t pos = ::lseek64(fd,0,SEEK_CUR);
        char buff[128];
        time_t t = dg->seq.clock().seconds();
        strftime(buff,128,"%H:%M:%S",localtime(&t));
        printf("%s.%09u dmg %08x @ %llu\n",
               buff,dg->seq.clock().nanoseconds(),dg->xtc.damage.value(),pos);
      }
#endif

      if (sz + sizeof(Pds::Dgram) > _eventsize) {
        printf("Event size (%d) is greater than pool size(%d)\n",
               sz, _eventsize);
        printf("Skipping remainder of file.\n");
      }
      else {
        rsz = ::read(fd, dg->xtc.payload(), sz);
        if (rsz == ssize_t(sz)) {
          _pend.push(b);
          sem_post(&_pend_sem);
          return true;
        }
      }
    }

    _free.push(b);
    sem_post(&_free_sem);
    
    _pend.push(0);
    sem_post(&_pend_sem);

    if (_live) {
      printf("\rLive read waits...");
      fflush(stdout);
      sleep(1);
      return true;
    }
    else
      return false;
  }
  Pds::Dgram* pop(Pds::Dgram* r)
  {
    if (r) {
      _free.push(reinterpret_cast<char*>(r));
      sem_post(&_free_sem);
    }

    sem_wait(&_pend_sem);
    char* b = _pend.front();
    _pend.pop();
    return reinterpret_cast<Pds::Dgram*>(b);
  }
private:
  queue<char*> _pend;
  queue<char*> _free;
  sem_t _pend_sem;
  sem_t _free_sem;
  unsigned _eventsize;
};

class XtcSlice {
public:
  XtcSlice(std::string fname);
  ~XtcSlice();
public:
  bool add_file(std::string fname);
public:
  void   init();
  Result next(Pds::Dgram*& dg);
  Result skip();
public:
  const Pds::Dgram& hdr() const { return *_nextdg; }
private:
  bool _open ();
  void _close();
  Result _next();
  Result _read(void* buf, ssize_t insz, bool seekNewChunk);
public:
  bool read();
private:
  std::string _base;
  std::list<std::string> _chunks;
  std::list<std::string>::iterator _current;
  Pds::Dgram* _lastdg;
  Pds::Dgram* _nextdg;
  int _fd;
  pthread_attr_t _flags;
  pthread_t _threadID;
  XtcPool _pool;
  volatile bool _bclose;
};

XtcSlice::XtcSlice(std::string fname) :
  _base(fname.substr(0,fname.find("-c"))),
  _current(_chunks.begin()),
  _lastdg(0),
  _nextdg(0),
  _fd  (-1),
  _pool(4,0x1000000),
  _bclose(false)
{
  _chunks.push_back(fname);
}

XtcSlice::~XtcSlice() 
{
  _close();
}

bool XtcSlice::add_file(std::string fname) 
{
  if (fname.compare(0,_base.size(),_base)!=0) 
    return false;
  
  for(std::list<std::string>::iterator it=_chunks.begin();
      it!=_chunks.end(); it++)
    if (fname < (*it)) {
      _chunks.insert(it,fname);
      return true;
    }
  _chunks.push_back(fname);
  return true;
}

void XtcSlice::init()
{
  _current = _chunks.begin();
  if (!_open())
    exit(1);
}

Result XtcSlice::next(Pds::Dgram*& dg)
{
  dg = _nextdg;
  Result r = _next();

  return r;
}

Result XtcSlice::skip()
{
  Pds::Dgram* dg;
  return next(dg);
}

bool XtcSlice::_open()
{
  const char* fname = _current->data();
  _fd = ::open(fname,O_LARGEFILE,O_RDONLY);
  if (_fd == -1) {
    char buff[256];
    sprintf(buff,"Error opening file %s\n",fname);
    perror(buff);
    return false;
  }
  else {
    //    printf("Opened file %s\n",fname);
  }

  pthread_create(&_threadID, NULL, readSlice, this);

  _nextdg = _pool.pop(_lastdg);
  _lastdg = 0;
  return true;
}

void XtcSlice::_close() 
{
  if (_live) {
    _bclose=true;
    pthread_join(_threadID,NULL);
    _bclose=false;
  }
  if (_fd)
    ::close(_fd); 
}

Result XtcSlice::_next()
{
  bool endRun = (_nextdg->seq.service()==Pds::TransitionId::EndRun);

  Pds::Dgram* dg = _nextdg;
  _nextdg = _pool.pop(_lastdg);
  _lastdg = dg;

  if (!_nextdg) {
    if (_live) {
      if (endRun) {
        _close();
        return End;
      }
      else {  // seek a new chunk else retry
        while(_nextdg==0) {
          int chunkPosition = _current->find("-c")+2;
          int chunkIndex = strtoul(_current->data()+chunkPosition, NULL, 10)+1;
          char chunkBuff[4]; sprintf(chunkBuff,"%02d",chunkIndex);
          std::string fname = _current->substr(0,chunkPosition) + std::string(chunkBuff) +
            _current->substr(chunkPosition+2);

          struct stat _stat;
          if (stat(fname.data(),&_stat)==0) {
            _chunks.push_back(fname);
            _current = _chunks.begin();
            while( *_current != fname )
              ++_current;
            _close();
            if (!_open())
              return Error;
            else
              return OK;
          }
          else {
            _nextdg = _pool.pop(_lastdg);
            _lastdg = 0;
          }
        }
      }
    }
    else {
      if (!endRun)
        printf("Unexpected eof in %s\n",_current->data());
      _close();
      if (++_current == _chunks.end()) 
        return End;
      if (!_open())
        return Error;
      return OK;
    }
  }

  return OK;
}

bool XtcSlice::read()
{
  return _pool.push(_fd) && !_bclose;
}

void* readSlice(void* arg)
{
  XtcSlice* s = (XtcSlice*)arg;
  while(s->read()) ;
  return NULL;
}


XtcRun::XtcRun() {}

XtcRun::~XtcRun() 
{
  for(std::list<XtcSlice*>::iterator it=_slices.begin();
      it!=_slices.end(); it++)
    delete (*it);
  _slices.clear();
} 

void XtcRun::reset   (std::string fname) 
{
  for(std::list<XtcSlice*>::iterator it=_slices.begin();
      it!=_slices.end(); it++)
    delete (*it);
  _slices.clear();
  _slices.push_back(new XtcSlice(fname));
  _base = fname.substr(0,fname.find("-s"));
}

bool XtcRun::add_file(std::string fname) 
{
  if (fname.compare(0,_base.size(),_base)!=0)
    return false;

  for(std::list<XtcSlice*>::iterator it=_slices.begin();
      it!=_slices.end(); it++)
    if ((*it)->add_file(fname))
      return true;
  _slices.push_back(new XtcSlice(fname));
  return true;
}

const char* XtcRun::base() const
{ return _base.data(); }

unsigned XtcRun::run_number() const 
{ return atoi(_base.data()+_base.find("-r")+2); }


void XtcRun::init() 
{
  for(std::list<XtcSlice*>::iterator it=_slices.begin();
      it!=_slices.end(); it++)
    (*it)->init();
}

Result XtcRun::next(Pds::Dgram*& dg)
{
  //
  //  Process L1A with lowest clock time first
  //
  Pds::ClockTime tmin(-1,-1);
  std::list<XtcSlice*>::iterator n  = _slices.begin();
  for(std::list<XtcSlice*>::iterator it = _slices.begin();
      it != _slices.end(); it++) {
    if ((*it)->hdr().seq.service()==Pds::TransitionId::L1Accept &&
        tmin > (*it)->hdr().seq.clock())
      tmin = (*(n = it))->hdr().seq.clock();
  }

  //
  //  On a transition, advance all slices
  //
  if ((*n)->hdr().seq.service()!=Pds::TransitionId::L1Accept) {
    for(std::list<XtcSlice*>::iterator it = _slices.begin();
        it != _slices.end();) {
      if (it != n && (*it)->skip()==End) {
        delete (*it);
        std::list<XtcSlice*>::iterator ee = it++;
        _slices.erase(ee);
      }
      else
        it++;
    }
  }
  Result r = (*n)->next(dg);
  if (r == End) {
    delete (*n);
    _slices.erase(n);
    if (_slices.size())
      r = OK;
  }
  return r;
}
